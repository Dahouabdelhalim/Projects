##Load R packages that are required

library(asnipe)
library(ape)
library(igraph)
library(sna)
library(ergm)
library(ergm.count)
library(tnet)
library(assortnet)

do_analysis<-function(exportdir1,exportdir2,filename,currrep){
	#exportdir1 - export directory where networks generated by network generator functions are stored
	#exportdir2 - director for analysis results to be stored
	#filename - parameter set to be analysed
	#currrep - rep of the parameter set to be analysed
	#Prep export folders
	if(!dir.exists(file.path(exportdir2,filename))){
		dir.create(file.path(exportdir2,filename))
	}
	
	resultfolders=c("ergmresult","randeffresult")
	for(folder in resultfolders){
		fulldir=file.path(exportdir2,filename,folder,sep="/")
		if(!dir.exists(fulldir)){
			dir.create(fulldir)
		}
	}
	#load locations
	eventlocs=get_obs_group_loc(exportdir1,filename,currrep)
	gbimat=get_gbimat(exportdir1,filename,currrep)
	indiv_dat=get_indiv_dat(exportdir1,filename,currrep)
	dist.centroids=get_dist_centroids(exportdir1,filename,currrep)
	obsnet=get_obs_net(exportdir1,filename,currrep)
	#make sure names match up
	row.names(obsnet)=colnames(obsnet)
	row.names(dist.centroids)=colnames(dist.centroids)=row.names(obsnet)
	
	#remove any individuals that were not observed in any of the networks
	miss.obs=get_missing(obsnet)
	miss.gbi=get_missing(gbimat)
	obsnet=obsnet[!miss.obs,!miss.obs]
	gbimat=gbimat[,!miss.gbi]
	dist.centroids2=dist.centroids[!miss.gbi,!miss.gbi]
	nres=colSums(gbimat)
	
	#convert gbimat to association matrix
	gbinet2=asnipe::get_network(gbimat)
	
	#do ergm analysis
	obs.ergm=do_ergm(obsnet,indiv_dat,miss.obs,dist.centroids2)
    obs.ergm=data.frame(effect=row.names(obs.ergm),obs.ergm,type="OBS",rep=currrep)      
    
	gbi.ergm=do_ergm(gbinet2,indiv_dat,miss.gbi,dist.centroids2,nres)
    gbi.ergm=data.frame(effect=row.names(gbi.ergm),gbi.ergm,type="GBI",rep=currrep)
	
	#do randomisation analysis
	obs.rand=do_randomisations(obsnet,indiv_dat,miss.obs,10000)#node swaps
	gbi.rand=do_randomisations(gbinet2,indiv_dat,miss.gbi,10000,cgbimat=gbimat,evlocs=eventlocs)#datastream permutations

	#add extra info to dataframes and organise
	obs.rand=data.frame(obs.rand,type="OBS",rep=currrep)
	gbi.rand=data.frame(gbi.rand,type="GBI",rep=currrep)

	rand.eff.result=rbind(obs.rand[[2]],gbi.rand[[2]])
	
	ergm.result=rbind(obs.ergm,gbi.ergm)	
	
	#Do exports
	write.csv(ergm.result,file.path(exportdir2,filename,resultfolders[1],paste0(currep,".csv")),row.names=F)
	write.csv(rand.eff.result,file.path(exportdir2,filename,resultfolders[2],paste0(currep,".csv")),row.names=F)
	
}

do_randomisations<-function(net,indiv_dat2,miss,nrand=1000,swapn=1,cgbimat=NA,evlocs=NA){
	#net=association matrix
	#indiv_dat2 = individual data from network generator
	#miss = boolean of missing individuals who never appear in the network
	#nrand = number of randomisations to carry out
	#swapn = number of swaps to carry out per randomisation
	#cgbimat = group by individual matrix - if not provided, node label swaps are carried out
	#evlocs = locations of grouping events
	
	#remove missing individual from indiv_dat
	indiv_dat2=indiv_dat2[!miss,]
	
	#calculate weighted degree
	wdeg<-colSums(net)
	
	#store results
	r.effs<-rep(NA,nrand)

	
	if(!is.na(sum(cgbimat))){
		#if group by individual matrix is provided do datastream permutations
		
		#calculate real effect of sex
		net.mod<-lm(wdeg~indiv_dat2$sex)
		perm<-list(cgbimat,net)
		#start loop through datastream permutations
		for(ii in 1:nrand){
			#check if locations are given, restrict swaps if given
			if(is.na(evlocs)){
				random_networks_gbi<-network_swap(association_data=perm[[1]],association_matrix=perm[[2]], swaps=swapn)
			}else{
				random_networks_gbi<-network_swap(association_data=perm[[1]],association_matrix=perm[[2]],swaps=swapn,locations=evlocs,within_location=T)
			} 
			#get gbi
			newgbi<-random_networks_gbi[[2]]
			#conver to association matrix
			r.gbinet<-asnipe::get_network(random_networks_gbi[[2]])
			
			#store new gbi and new association matrix
			perm<-list(newgbi,r.gbinet)
			

			
			#calculate effect of sex in random network
			tmp.wdeg<-colSums(r.gbinet)
			tmp.mod<-lm(tmp.wdeg~indiv_dat2$sex)
			#store results
			r.effs[ii]<-coef(tmp.mod)[2]
		}
	} else {
		#if no gbi matrix, do node swaps on association matrix
		
		#calculate real effect of sex
		net.mod<-glm(wdeg~indiv_dat2$sex,family=poisson)
		rnet=net
		for(ii in 1:nrand){
 			#node swaps
 			rnet<-rmperm(rnet) 
						
			#calculate effect of sex in random network
 			tmp.wdeg<-colSums(rnet)
			tmp.mod<-glm(tmp.wdeg~indiv_dat2$sex,family=poisson)
			
			#store results
 			r.effs[ii]<-coef(tmp.mod)[2]
 		}
	}
	
	pval=c(sum(r.effs<coef(net.mod)[2])/(nrand+1),sum(r.effs>coef(net.mod)[2])/(nrand+1))[(coef(net.mod)[2]>0)+1]
	
	return(data.frame(realeff=coef(net.mod)[2],
		data.frame(t(quantile(r.effs,c(0.005,0.025,0.975,0.995),na.rm=T))),
		pval=pval)
	)
	
}

do_ergm<-function(net,indiv_dat2,miss,dist.centroids2,nres2=NA){
	#remove missing individual from indiv_dat
	indiv_dat2=indiv_dat2[!miss,]
	
	#set up observed network as a network object
	NET2.edgelist<-as.tnet(as.matrix(net))
	NET2<-network(NET2.edgelist, directed=F, ignore.eval=F, names.eval="weight")

	#add attributes
	set.vertex.attribute(NET2,"group",as.vector(indiv_dat2$groups))
	set.vertex.attribute(NET2,"sex",as.vector(indiv_dat2$sex))
	if(!is.na(sum(nres2))){
		set.vertex.attribute(NET2,"nres",as.vector(nres2))
	}

	#shared group matrix
	mat1=matrix(rep(indiv_dat2$groups,each=ncol(net)),nrow=nrow(net))
	mat2=matrix(rep(indiv_dat2$groups,each=ncol(net)),nrow=nrow(net),byrow=T)
	sh.gr=mat1==mat2
	sh.gr[sh.gr]=1
	
	diag(sh.gr)<-0
	
	#distance between groups matrix
	mat1x=matrix(rep(indiv_dat2$x,each=ncol(net)),nrow=nrow(net))
	mat1y=matrix(rep(indiv_dat2$y,each=ncol(net)),nrow=nrow(net))
	mat2x=matrix(rep(indiv_dat2$x,each=ncol(net)),nrow=nrow(net),byrow=T)
	mat2y=matrix(rep(indiv_dat2$y,each=ncol(net)),nrow=nrow(net),byrow=T)

	dist.gr=((mat1x-mat2x)^2+(mat1y-mat2y)^2)^0.5


	if(is.na(sum(nres2))){
		modB_2<-ergm(NET2~sum+nonzero+nodefactor("sex")+nodematch("sex")+edgecov(sh.gr)+edgecov(dist.gr),reference=~Poisson,response="weight")
	} else {
		modB_2<-ergm(NET2~sum+nonzero+nodefactor("sex")+nodematch("sex")+edgecov(dist.centroids2),reference=~Poisson,response="weight")
	}
	resultdf=summary(modB_2)$coefs
	return(resultdf)

}

get_gbimat<-function(exportdir1,filename,currrep){
	currfp=file.path(exportdir1,filename,"obsgbimat",paste(currrep,".csv",sep=""))
	gbimat<-read.csv(currfp,check.names=FALSE)
	return(gbimat)
}

get_indiv_dat<-function(exportdir1,filename,currrep){
	currfp=file.path(exportdir1,filename,"popdat",paste(currrep,".csv",sep=""))
	indiv_dat<-read.csv(currfp,check.names=FALSE)
	return(indiv_dat)
}


get_obs_net<-function(exportdir1,filename,currrep){
	currfp=file.path(exportdir1,filename,"obsnet",paste(currrep,".csv",sep=""))
	obsnet<-read.csv(currfp,check.names=FALSE)
	return(obsnet)
}


get_obs_group_loc<-function(exportdir1,filename,currrep){
	#function to load locations
	currfp=file.path(exportdir1,filename,"obsgbigroups",paste(currrep,".csv",sep=""))
	grouplocs1<-read.csv(currfp,check.names=FALSE)
	return(grouplocs1$x)
}

get_dist_centroids<-function(exportdir1,filename,currrep){
	#works out home range centroids for each individual and distances between them
	currfp=file.path(exportdir1,filename,"obsgbigroups",paste(currrep,".csv",sep=""))
	grouplocs1<-read.csv(currfp,check.names=FALSE)
	names(grouplocs1)<-"Gr"
	gbimat=get_gbimat(exportdir1,filename,currrep)

	currfp=file.path(exportdir1,filename,"popdat",paste(currrep,".csv",sep=""))
	indiv_dat<-read.csv(currfp,check.names=FALSE)


	grouplocs1$x<-rep(NA,nrow(grouplocs1))
	grouplocs1$y<-rep(NA,nrow(grouplocs1))
	
	grouplocs1$x=sapply(1:nrow(grouplocs1),function (i){
		indiv_dat$x[min(which(indiv_dat$groups==grouplocs1$Gr[i]))]
	})
	grouplocs1$y=sapply(1:nrow(grouplocs1),function (i){
		indiv_dat$y[min(which(indiv_dat$groups==grouplocs1$Gr[i]))]
	})
	
	indiv.groups=lapply(1:nrow(indiv_dat),function (i){
		which(gbimat[,i]==1)
	})

	indiv.centroids<-data.frame(indiv_dat$indivs)
	names(indiv.centroids)<-"id"

	indiv.centroids$x=sapply(1:nrow(indiv.centroids),function (i){
		mean(grouplocs1$x[indiv.groups[[i]]])
	})

	indiv.centroids$y=sapply(1:nrow(indiv.centroids),function (i){
		mean(grouplocs1$y[indiv.groups[[i]]])
	})

	dist.centroids<-as.matrix(dist(indiv.centroids[,2:3]))
	return(dist.centroids)
}

get_missing=function(net){
	miss=(colSums(net)==0)
	return(miss)
}



