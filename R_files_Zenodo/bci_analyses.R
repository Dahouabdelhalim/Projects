################################################################################
## Filename: bci_analyses.R
## Authors: Helene C. Muller-Landau and Marco D. Visser
## Article title: How do lianas and vines influence competitive differences 
##                and niche differences among tree species?
##                Concepts and a case study in a tropical forest 
## Purpose of this code: Conduct statistical tests given species-level 
##       statistics on tree-liana interactions generated by bcispeciescalcs.r
################################################################################

rm(list=ls()) # clear workspace

### input filenames 
indir <- "./objects"
fnstatlianacsv <- paste0(indir,"treespstatsrelianas.csv")
statbsfn <- paste0(indir,"bootstraplianastats.rds")

### output filenames and filenamestems 
outdir <- "./testresults/"
fnoutrandprevload <- "ResultsRandPrevLoad.csv"
fnoutaltburd <- "ResultsAltBurden.csv"
fnoutcor <- "ResultsCorrelations.csv"
fncompcor <- "CompareResultsCorrelations.csv"

### temporary filenames 
fndatalowsdtolcsv <- paste0(outdir,"datalowsdtol.csv")
fndatalowsdburdcsv <- paste0(outdir,"datalowsdburd.csv")
fndatalowsdburdtolcsv <- paste0(outdir,"datalowsdburdtol.csv")

### CONSTANTS
ALLCOVERS  <-  c(0,1/8,3/8,5/8,7/8) # proportional liana covers for classes 0 to 4
ALPHA <- 0.05 # p-values for confidence intervals 
PLO <- ALPHA/2
PHI <- 1-ALPHA/2

################################################################################
# calculations for figure S2
# calculate expected standard deviations of prevalence and load over species
# if liana cover was randomly distributed across species 
calcrandsdprevload <- function(sp,nbycover,allcovers=ALLCOVERS,nboot=1000) {
  Ntotbysp <- apply(nbycover,1,sum)
  Ntotbycov <- apply(nbycover,2,sum)
  Nall <- sum(nbycover)
  allsp <- c(rep(sp,Ntotbysp))
  allcover <- c(rep(allcovers,Ntotbycov))
  sampprev <- sampload <- matrix(-0.9,nrow=length(sp),ncol=nboot)
  for (i in 1:nboot) {
    thiscover <- sample(allcover,size=Nall,replace=TRUE)
    thiscovernonzero <- ifelse(thiscover>0,1,0)
    sampprev[,i] <- tapply(thiscovernonzero,allsp,mean)
    sampload[,i] <- tapply(thiscover[thiscover>0],allsp[thiscover>0],mean)
  }
  
  bsprevsd <- apply(sampprev,2,sd)
  bsloadsd <- apply(sampload,2,sd)
  
  return(list(bsprevsd=bsprevsd,bsloadsd=bsloadsd))
} # end calcrandprevload



################################################################################
# calculations for figure S4
calcaltburden <- function(fndatacsv,nlianaclass=4) {
  
  ## get previously prepared data (in H_analysis_PrevLoadToleranceBurden.R)
  totDat <- read.csv(fndatacsv,as.is=TRUE)
  nsp <- dim(totDat)[1]
  
  Nbycover1234 <- totDat[,c("N1","N2","N3","N4")]
  lambda1234 <- totDat[,c("lambda1","lambda2","lambda3","lambda4")]
  qs <- Nbycover1234/totDat$Ninf # proportion of total infested in each non-zero infestation class
  difloglamb1234 <- log(lambda1234)-log(totDat$lambda0)
  
  
  meanprev <- rep(mean(totDat$prevalence),nsp)  # mean prevalences
  meanqs <- matrix(rep(apply(qs,2,mean),each=nsp),nrow=nsp,ncol=nlianaclass)  # mean load stats
  meandifloglamb <- matrix(rep(apply(difloglamb1234,2,mean),each=nsp),nrow=nsp,ncol=nlianaclass) # mean tolerance stats 
  
  burdendf <- data.frame(sp=totDat$sp,
                      burdentrue=totDat$prevalence*apply(qs*difloglamb1234,1,sum),
                      burdennoprev=meanprev*apply(qs*difloglamb1234,1,sum),
                      burdennoload=totDat$prevalence*apply(meanqs*difloglamb1234,1,sum),
                      burdennotol=totDat$prevalence*apply(qs*meandifloglamb,1,sum))
  return(burdendf)
} # end calcaltburden





################################################################################
# function to get CIs from bootstrapped parameter value datasets
# varbs is a matrix with the species in columns, and bootstrapped replicates in rows 
getCIfrombs <- function(varbs,varname) {
  thisdf <- data.frame(LoCI=apply(varbs,2,quantile,probs=PLO,na.rm=TRUE),
                    HiCI=apply(varbs,2,quantile,probs=PHI,na.rm=TRUE))
  names(thisdf) <- paste0(varname,names(thisdf))
  return(thisdf)
} # end getCIfrombs




################################################################################
getallcorsbyname <- function(dataset,xnames,ynames,method="pearson",returnall=FALSE) {
  ncor <- length(xnames)
  
  rcor <- pval <- rep(NA,ncor)
  for (i in 1:ncor) {
    thiscortest <- cor.test(dataset[,names(dataset)==xnames[i]],
                            dataset[,names(dataset)==ynames[i]],
                         method=method)
    rcor[i] <- thiscortest$estimate
    pval[i] <- thiscortest$p.value
  }
  
  if(returnall)
    results <- data.frame(xvar=xnames,yvar=ynames,rcor=rcor,pval=pval,method=method)
  else
    results <- rcor
  return(results)
} # end getallcorsbyname


################################################################################
# get confidence intervals on correlation coefficients from previously run bootstraps
# over lambdas and (independently) over trees
getcorbsCIs <- function(datacsvfn,statbsfn,xnames,ynames) {
  
  totDat <- read.csv(file=datacsvfn,as.is=TRUE)
  
  # get observed correlations in full dataset
  obscorregs <- getallcorsbyname(totDat[,c("loglambda0","loglambda4","loglambdaTot",
                                        "prevalence","load","tolerance","burden",
                                        "shadetol","sfvissis","sfvistol")],
                              xnames=xnames,ynames=ynames,method="pearson",returnall=TRUE)
  obscorranks <- getallcorsbyname(totDat[,c("loglambda0","loglambda4","loglambdaTot",
                                         "prevalence","load","tolerance","burden",
                                         "shadetol","sfvissis","sfvistol")],
                               xnames=xnames,ynames=ynames,method="spearman",returnall=TRUE)
  
  # get previous sets of bootstrapped variables 
  statbs <- readRDS(statbsfn)
  
  usestatbs <- statbs[!is.na(match(dimnames(statbs)[[1]],totDat$sp)),,]
  nboot <- dim(usestatbs)[3]
  
  nsp <- nrow(totDat)
  nstat <- nrow(obscorregs)
  corregbs <- corrankbs <- matrix(-9.99,nrow=nboot,ncol=nstat) # for correlation stats 
  for(i in 1:nboot){
    thisstat <- cbind(totDat[,c("shadetol","sfvissis","sfvistol")],as.data.frame(usestatbs[,,i]))
    thiscorreg <- getallcorsbyname(thisstat,xnames,ynames,method="pearson")  
    corregbs[i,] <- thiscorreg
    thiscorrank <- getallcorsbyname(thisstat,xnames,ynames,method="spearman")  
    corrankbs[i,] <- thiscorrank
    cat("\\r",round(i/nboot,3)*100,"% \\r") # this takes a while to run - let the user know something is happening
  }
  regcorstats <- obscorregs
  # note - there are NAs in the tolerances in some bootstraps, 
  # and these result in NAs in correlations for those iterations
  regcorstats$loCI <- apply(corregbs,2,quantile,probs=PLO,na.rm=TRUE)
  regcorstats$hiCI <- apply(corregbs,2,quantile,probs=PHI,na.rm=TRUE)
  regcorstats$cortype <- "regular"
  rankcorstats <- obscorranks
  rankcorstats$loCI <- apply(corrankbs,2,quantile,probs=PLO,na.rm=TRUE)
  rankcorstats$hiCI <- apply(corrankbs,2,quantile,probs=PHI,na.rm=TRUE)
  rankcorstats$cortype <- "rank"
  allcorstats <- rbind(regcorstats,rankcorstats)
  allcorstats$n <- nsp
  allcorstats$dataname <- datacsvfn
  
  return(list(corstats=allcorstats)) 
} # end getcorbsCIs



################################################################################
# get range of correlation coefficients from jackknifing over species 
getcorjacknifeCIs <- function(datacsvfn,
                           xnames=c("loglambdaTot","loglambdaTot",rep("burden",3),
                                    "prevalence","prevalence","load",rep("shadetol",4)),
                           ynames=c("loglambda0","loglambda4","prevalence","load",
                                    "tolerance","load","tolerance","tolerance",
                                    "burden","prevalence","load","tolerance")) {
  
  totDat <- read.csv(file=datacsvfn,as.is=TRUE)
  
  nsp <- nrow(totDat)
  nstat <- length(xnames)
  corregjk <- corrankjk <- matrix(-9.99,nrow=nsp,ncol=nstat) # for correlation stats 
  for(i in 1:nsp){
    thisdat <- totDat[-i,]
    thiscorreg <- getallcorsbyname(thisdat,xnames,ynames,method="pearson")  
    corregjk[i,] <- thiscorreg
    thiscorrank <- getallcorsbyname(thisdat,xnames,ynames,method="spearman")  
    corrankjk[i,] <- thiscorrank
  }
  # note - there are NAs in the tolerances in some bootstraps, 
  # and these result in NAs in correlations for those iterations
  regcorstats <- data.frame(xvar=xnames,yvar=ynames,
                         minjk=apply(corregjk,2,min,na.rm=TRUE),
                         maxjk=apply(corregjk,2,max,na.rm=TRUE),
                         cortype="regular")
  rankcorstats <- data.frame(xvar=xnames,yvar=ynames,
                          minjk=apply(corrankjk,2,min,na.rm=TRUE),
                          maxjk=apply(corrankjk,2,max,na.rm=TRUE),
                          cortype="rank")
  allcorstats <- rbind(regcorstats,rankcorstats)
  allcorstats$n <- nsp
  allcorstats$dataname <- datacsvfn
  
  return(allcorstats) 
  
} # end getcorjacknifeCIs

###############################################################
getsigstring <- function(pval) {
  sigstring <- ifelse(pval>0.05,"ns",
                   ifelse(pval>0.01,"*",
                          ifelse(pval>0.001,"**","***")))
  return(sigstring)
} # end getsigstring


###############################################################
# make a table comparing the correlation results from different sets of species 
makecorcomptable <- function(allresults,statnames) {
  thiscorstats <- allresults[[1]]$corstats
  thiscorstats <- thiscorstats[thiscorstats$cortype=="regular",]
  cortable <- thiscorstats[,c("xvar","yvar")]
  nsets <- length(allresults)
  allcors <- matrix(nrow=nrow(cortable),ncol=nsets,
                 dimnames=list(rownames(cortable),statnames))
  Jackknife <- paste0(sprintf("%.2f",thiscorstats$minjk), ",",
                   sprintf("%.2f",thiscorstats$maxjk))
  for (i in 1:nsets) {
    thiscorstats <- allresults[[i]]$corstats
    thiscorstats <- thiscorstats[thiscorstats$cortype=="regular",]
    thiscorstats$cor <- as.numeric(as.character(thiscorstats$rcor))
    allcors[,i] <- paste0(sprintf("%.2f",thiscorstats$cor),
                       getsigstring(thiscorstats$pval)," (",
                       sprintf("%.2f",thiscorstats$loCI),",",
                       sprintf("%.2f",thiscorstats$hiCI),")")
  }
  cortable <- cbind(cortable,allcors,Jackknife)
  ns <- rep(NA,nsets+1)
  for (i in 1:nsets) ns[i] <- allresults[[i]]$corstats$n[1] 
  ns[nsets+1] <- 32
  nsrow <- c("","",paste0("(n=",ns,")"))
  names(cortable) <- paste(names(cortable),nsrow,sep=" ")
  
  return(cortable)
} # end makecorcomptable




################################################################################
doallcorrelations <- function(fnstatlianacsv=fnstatlianacsv,outdir=outdir,outfnprefix="") {
  # CIs on the correlations from bootstrapping and jacknifing 
  xnames <- c("loglambdaTot","loglambdaTot",rep("burden",3),
           "prevalence","prevalence","load",
           rep(c("shadetol","sfvissis","sfvistol"),each=4))
  ynames <- c("loglambda0","loglambda4","prevalence","load","tolerance",
           "load","tolerance","tolerance",
           rep(c("burden","prevalence","load","tolerance"),times=3))
  
  jkcorstats <- getcorjacknifeCIs(fnstatlianacsv,xnames=xnames,ynames=ynames) 
  
  resultsallcorbs <- getcorbsCIs(fnstatlianacsv,statbsfn,xnames=xnames,ynames=ynames) 
  corstats <- cbind(resultsallcorbs[[1]],jkcorstats[,c("minjk","maxjk")])
  write.csv(corstats,file=paste0(outdir,outfnprefix,fnoutcor),row.names=FALSE)
  return(list(corstats=corstats))
} # end doallcorrelations


# analyses for figure S2
totDat <- read.csv(file=fnstatlianacsv)
bsstats <- calcrandsdprevload(totDat$sp,totDat[,c("N0","N1","N2","N3","N4")])
write.csv(bsstats,file=paste0(outdir,fnoutrandprevload),row.names=FALSE)

# analyses for figure S4
altburdendf <- calcaltburden(fnstatlianacsv)
write.csv(altburdendf,file=paste0(outdir,fnoutaltburd),row.names=FALSE)

# analyses for all correlation coefficients related to figures 3, 4, 5, S3, S5
allstats <- doallcorrelations(fnstatlianacsv=fnstatlianacsv,outdir=outdir,outfnprefix="")

# analyses for Table S2: alternate scenarios removing species with high uncertainty
alldata <- read.csv(fnstatlianacsv,as.is=TRUE)
write.csv(alldata[alldata$toleranceSD<0.03,],file=fndatalowsdtolcsv,row.names=FALSE)
write.csv(alldata[alldata$burdenSD<0.01,],file=fndatalowsdburdcsv,row.names=FALSE)
write.csv(alldata[alldata$burdenSD<0.01&alldata$toleranceSD<0.03,],
          file=fndatalowsdburdtolcsv,row.names=FALSE)

xallstats <- doallcorrelations(fnstatlianacsv=fndatalowsdburdcsv,outdir=outdir,outfnprefix="X")
yallstats <- doallcorrelations(fnstatlianacsv=fndatalowsdtolcsv,outdir=outdir,outfnprefix="Y")
zallstats <- doallcorrelations(fnstatlianacsv=fndatalowsdburdtolcsv,outdir=outdir,outfnprefix="Z")

allresults <- list(allstats,xallstats,yallstats,zallstats)
statnames <- c("All species","BurdSD<0.01","TolSD<0.03","BSD<0.01&TSD<0.03")
cortable <- makecorcomptable(allresults,statnames) 
write.csv(cortable,file=paste0(outdir,fncompcor),row.names=FALSE)
  


